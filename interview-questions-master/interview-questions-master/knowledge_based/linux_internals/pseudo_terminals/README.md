# Pseudo-terminals

(Based on Chapter 19 of *Advanced Programming in the UNIX Environment*)

A pseudo-terminal is a pair of connected endpoints where one of the endpoints (the slave) simulates a terminal device that is controlled by the other endpoint (the master). The master and the slave are connected, and anything written to the PTY master appears as input in the PTY slave, and anything written to the PTY slave appears as input in the PTY master.

These days, pseudo-terminals play a very important role in the UNIX and Linux world. The days of serial-port hardwired dumb terminals long gone. Instead, users manage the system using a pseudo-terminal, usually behind a terminal emulator on a windowing system. The basic architecture is as follows: there is a window manager to handle the windowing system. A terminal emulator is just another GUI application running on the system. When a user opens a terminal emulator, a pseudo-terminal master and slave pair is created with `forkpty(3)`. `forkpty(3)` is a library call. It calls `posix_openpt(2)`, which in Linux is equivalent to `open("/dev/ptmx", flags)`, to obtain a file descriptor for a new PTY master device. The PTY master device is then initialized with `grantpt(3)` to update the mode and owner of the corresponding slave pseudoterminal (the user ID of the slave is set to the real UID of the calling process). The slave pseudoterminal is then made public with `unlockpt(3)`. This must be done before attempting to open the slave pseudoterminal. Then, the process forks. The parent controls the master pseudoterminal; the child creates a new session with `setsid(2)`. The creation of a new session detaches the child process of the current controlling terminal (if there is one), and makes the child the session leader of a new session, and the group leader of a group. Then, the PTY slave device is opened in the child process and duplicated onto stdin, stdout and stderr. Because this child process is a session leader, and there was no controlling terminal allocated to the session, opening the PTY slave device automatically makes it the controlling terminal for the session. Finally, `forkpty(3)` returns 0 in the child and `X` in the parent, where `X` is the pid of the child process.

Then, the caller of `forkpty(3)` calls one of the seven `exec()` functions to execute the user's shell. The windowing system is responsible for reading input from the keyboard and notifying the process running the terminal emulator, which in turn writes that input into the PTY master device. The input makes its way into the slave PTY, and if echo is enabled in the PTY device, it travels back to the PTY master (as output).

The process is very similar for remote login servers like SSH and telnet; instead of having a window manager on top of the terminal emulator, we have a daemon listening for connections and reading from multiple TCP/IP streams (perhaps using `select(2)` or `poll(2)`) and writing the results into the corresponding PTY master (and reading from the PTY master and writing into the socket).

## The PTY library

`pty_lib.c` shows a possible implementation for `posix_openpt(3)` and `forkpty(3)`. It defines two auxiliary functions that separate the actions of opening and allocating a PTY master and opening the corresponding PTY slave: `ptym_open()` and `ptys_open()`.

`ptym_open()` allocates and opens a new PTY master, returning its file descriptor. As a side effect, it also stores the pathname for the PTY slave device in the `pts_name` argument. If the pathname is too long for the buffer size, `ptym_open()` returns `-1` and sets `errno` to `ENAMETOOLONG`. In case of success, the PTY slave is initialized with `grantpt(3)` and made available with `unlockpt(3)` before returning.

`ptys_open()` opens a new slave pseudoterminal given its pathname, and returns the file descriptor. It returns an error under the same conditions that `open(2)` does.

`pty_fork()` is our homemade implementation of `forkpty(3)`. It calls `ptym_open()` to allocate a new PTY master/slave pair and then it forks. The child creates a new session, opens the PTY slave and duplicates it onto `stdin`, `stdout` and `stderr`. As in `fork(2)`, `pty_fork()` returns twice: in the parent and in the child. In the parent it returns the pid of the child process, or `-1` in case of error. In the child it returns `0`. Note that there are numerous edge cases here regarding error conditions that must be dealt with. In particular, some sort of atomicity requirement must be enforced: what happens if the parent succeeds but, for some reason, the the child process can't open the slave pseudoterminal, or `dup2(2)` fails? The child process has already been created, so what should we do? Return twice? Or abort the child and return `-1` in the parent?
Our implementation of `pty_fork()` offers a strong atomicity guarantee: it only returns twice if both the parent and the child succeeded. This is achieved with a pipe: the parent reads from a pipe that is used to learn about the status of the child. If anything goes wrong with the child, the value of `errno` in the child is written to the pipe and then the child terminates. The parent can then retrieve the error code and return it back to the caller. If the child succeeds, it writes `0` into the pipe and so the parent knows that it is safe to let the child live.

## The PTY program

The PTY program allows us to run a process in a new session with a new controlling terminal. It is particularly useful to see the output of long-living programs, because stdio enters line-buffering mode when running on a terminal device (as opposed to fully buffered when redirected to a file), which means that we can get output line by line in realtime. It also enables us to write driver programs that act with the underlying process by manipulating it through the terminal, similar to the functionalities offered by `expect(1)` (although slightly more primitive). The PTY program also forks a new process to manage both flows of data: a child process reads from `stdin` and writes to the PTY master, and the parent reads from the PTY master and writes to `stdout`. When in interactive mode, the user's terminal (not the new pseudo-terminal) is set to raw mode with the help of `cfmakeraw(3)`. The terminal's attributes are reset once `pty` terminates. If a driver program is used, or if interactive mode is disabled, the user's terminal settings are left untouched, and instead the driver's program `stdin` and `stdout` are connected through a pair of pipes to the pty parent's `stdout` and `stdin`. So, with a driver program, the flow is: the driver writes something to `stdout`, which flows through the pipe to the pty parent's `stdin`, which in turn is copied to the PTY master device, travels to the PTY slave, appears as input to the underlying process, travels again back to the PTY master (assuming echo is enabled), which is read by the pty child and written to `stdout`, which is redirected through another pipe to the driver's `stdin`.

We have to be careful with how EOF is handled on both sides; the `loop()` function makes use of `setjmp(3)` and `longjmp(3)` to prevent race conditions and to avoid having the parent hanging waiting for input that will never come. See the comments on that function to learn more.
