/*You are given a 0-indexed array nums and an integer target.

A 0-indexed array infinite_nums is generated by infinitely appending the elements of nums to itself.

Return the length of the shortest subarray of the array infinite_nums with a sum equal to target.
If there is no such subarray return -1.

Example 1:

Input: nums = [1,2,3], target = 5
Output: 2
Explanation: In this example infinite_nums = [1,2,3,1,2,3,1,2,...].
The subarray in the range [1,2], has the sum equal to target = 5 and length = 2.
It can be proven that 2 is the shortest length of a subarray with sum equal to target = 5.

Constraints:

1 <= nums.length <= 10^5
1 <= nums[i] <= 10^5
1 <= target <= 10^9

IDEA: since all nos are +ve, there are two cases
1. target <= total sum 
2. target > total sum

1. since we can append arrays at the end any # of times the target can be the sum of suffix + prefix of 
the array. So just append the array just once and find the subarray with sum=target. For that we can use
two pointer or the map approach
2. find the remaining target (target % total sum), ans = target/totalsum + ans to case 1
eg. a = [2,3,1], target = 9
[2 3 | 1] [2 3 1] [2 | 3 1]
*/
typedef long long ll;
class Solution {
public:
    // find min len subrray with sum target if array is concatenated once
    // using map
    int solve(vector<int> a, int target) {
        int n = a.size(), len = INT_MAX;
        ll sum = 0;
        unordered_map<ll, int> mp;
        for (int i = 0; i < 2*n; ++i) {
            sum += (ll)a[i % n];
            if (mp.count(sum-target)) {
                len = min(len, i-mp[sum-target]);
            }
            mp[sum] = i;
        }
        return len;
    }
    ////////////////////////////////////////////////////////////////
    //find min len subrray with sum target if array is concatenated once
    // using two pointer
    int solve(vector<int> a, int target) {
        int n = a.size(), len = INT_MAX;
        ll sum = 0;
        for (int st=0,end=0; end<2*n; ++end) {
            sum += (ll)a[end % n];
            while (st < end and sum > target) {
                sum -= a[st % n];
                st++;
            }
            if (sum == target) len = min(len, end-st+1);
        }
        return len;
    }
    ////////////////////////////////////////////////////////////////
    int minSizeSubarray(vector<int>& a, int target) {
        int n = a.size();
        ll totalsum = 0;
        for (int e: a) totalsum += e;
            if (target > totalsum) {
                int appends = target/totalsum;
                target %= totalsum;
                if (target == 0) return n * appends;
                int ans = n * appends;
                int len = solve(a, target);
                if (len == INT_MAX) return -1;
                return ans + len;
            }

            int len = solve(a, target);
            return len == INT_MAX ? -1 : len;
        }
    };